:toc:

== Design Concept of `commandunit`

=== YAML, not Gherkin

Gherkin is one notation widely used in "Cucumber"'s ecosystem.

[source, gherkin]
.A Gherkin (Cucumber) Example
----
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
----

If we write this in YAML, it will be like this:


[source, yaml]
.YAML version of Gherkin Example
----
---
Feature:
  Name: Guess the word <1>
  Scenarios:
  # The first example has two steps
  - Name: Maker starts a game
    When: the Maker starts a game
    Then: the Maker waits for a Breaker to join
  # The second example has three steps
  - Name: Breaker joins a game <1>
    Given: the Maker has started a game with the word "silky"
    When: the Breaker joins the Maker's game
    Then: the Breaker must guess a word with 5 characters
----
<1>: These attributes are introduced to define names of a feature and a scenario, which is defined without explicit attribute name in Gherkin.

Gherkin seems slightly simpler and cleaner since you will need fewer keywords, however, is it really worth adapting a dedicated notation not used anything but it?
By using Gherkin, you will need a set of plugins to support Gherkin for every tool used in a software development project such as browser, editor, or IDE.

If so, wouldn't YAML be good enough to define your test cases?
isn't YAML good enough, if we have a way to avoid repeating the same thing over and over again?


=== Powered by `jq-front`

`jq-front` <<jq-front-designConcept>> is a tool to enable your JSON files to extend other JSON files.
Not only that it allows you to reference another node in the same file to compute a node's value.

Following is an example of `jq-front` 's input data.
[source, json]
[[yamlpp-example-designConcept]]
.JSON++ example, `foo.json{plus}{plus}`
----
{
  "foo_database": {
    "$extends": [ "database_default.json" ],
    "db_name": "foo",
    "user": {
      "password": "foo_root"
    }
  }
}
----

`jq-front` renders this file into a normal JSON file, where the values defined inside `database_default.json` are expended and then overridden by the values in `foo.json{plus}{plus}` file.

It is a very flexible, yet still your files are JSON, as you see.
This means that you don't need to find supports of the new format.
You can just keep using your favorite tools (editor, browser, IDE, etc) because in general they support popular formats such as JSON, YAML, or the good old XML.

=== YAML -> JSON Pipeline

Let's go one step forward.
We use YAML in order to ensure the test case definitions readable for human.
We also use `jq-front`, which processes JSON files(`.json{plus}{plus}`) and renders into normal JSON files.

In short, instead of coming up with a single notation that solves all the problems at once, it applies tools that solve them one by one.

Following is an example of a file that written in YAML, using `jq-front` 's feature.

[source, yaml]
.YAML++ example, `foo.yaml{plus}{plus}`
----
foo_database:
  "$extends":
    - database_default
  server:
    port: 2001
  db_name: foo
  user:
    password: foo_root
----

This can be converted into a JSON file that uses `jq-front` feature, which is shown as the <<yamlpp-example-designConcept>>

=== References

- [[[jq-front-designConcept, 1]]] jq-front

[.text-right]
// suppress inspection "AsciiDocLinkResolve"
link:index.html[top]
